# Теоретическое ДЗ №3: Ещё анализ на решётках

### Вопрос №1:

Для liveness analysis:
* Какова сложность структурного алгоритма?
  * А если в CFG нет циклов
  * Какова сложность по памяти

### Ответ на вопрос №1:

`n` - число нод в AST, а `k` - число переменных.
* Если циклы есть, то можно вставить `O(n)` (после каждой инструкции с ветвлением) фи-нод, и тогда для каждой ноды `v` из AST будет верно, что `|pred(v)| ≤ 2` и `|pred(v)| ≤ 2`, поэтому можно перейти к случаю без циклов.
  * Получаем, что из `n * k` итераций алгоритма, на каждой из которых исполняем `≤ 2` операции с множествами размера `k`. Итого: `O(k^2 * n)`, что круто, поскольку `k` на практике сильно меньше `n`.
  * `O(k)` - нам не нужно `O(n * k)`, чтобы хранить состояние размера `O(k)` всех `n` нод AST, а достаточно лишь хранить состояние текущей ноды, и предыдущих / следующих (в зависимости от того backward / forward ли у нас анализ) `≤ 2` вершин.

### Вопрос №2:

Распишите и решите систему ограничений для very busy expressions анализа для этого примера:
```c#
var x,a,b;
x = input;
a = x-1;
b = x-2;
while (x > 0) {
    output a*b-x;
    x = x-1;
}
output a*b;
```

### Ответ на вопрос №2:

```c#
var x,a,b;          // {}
x = input;          // {}
a = x-1;            // {x-1}
b = x-2;            // {x-1, x-2}
while (x > 0) {     // {x-1, x-2, x>0}, затем {a*b, x>0}
    output a*b-x;   // {a*b, a*b-x, x-1, x-2, x>0}, затем {a*b, x>0}
    x = x-1;        // {a*b}
}
output a*b;         // {a*b}
```

Отсюда видно, что `a*b` можно объявить как константу, а `a` и `b` выкинуть.
