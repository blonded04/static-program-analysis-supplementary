# Экзамен

## Основные подходы к статическому анализу ПО. Сигнатурный поиск. Понятие абстрактного синтаксического дерева, другие модели ПО.

#### Основные подходы к статическому анализу ПО. Сигнатурный поиск.

Виды статического анализа:
* Анализ на основе типов
  * Человечество знает многое про системы типов, почему бы не представить анализ в виде системы типов и решения задачи типизации / вывода типов / населенности типов / etc.
* Абстрактная интерпретация
* Символьное исполнение
* Анализ потока данных
* Сигнатурный поиск
  * Работает благодаря поиску сигнатур: несколько тысяч сигнатур, которые анализатор пытается сопоставить с программой, и, при нахождении соответствия, говорит о том, что "maybe" всё ломается
* И так далее...

#### Понятие абстрактного синтаксического дерева, другие модели ПО.

Абстрактное синтаксическое дерево -- это дерево разбора программы, из которого выбрасывается всё, что синтаксически усложняет анализ. Например, для следующего statement программы:
```
while (i < 10) 
{
    i = i + 1
}
```

Можно построить следующее дерево:
![data/exam-ast.png]()

Кроме AST также имеет смысл использовать:
* ASG -- abstract semantic graph
* Control flow graph
* Dependency graph
* Нормальная форма кода

## Понятие контекстной чувствительности. Метод ограниченного клонирования процедур, его ограничения и параметризация. Методы улучшения контекстной чувствительности.

#### Понятие контекстной чувствительности.

Контекстная чувствительность становится остро необходима, когда речь заходит о межпроцедурных анализах, например, пусть мы не хотим, ради целей статического анализа инлайнить каждый вызов функции (хотя бы потому что это дорого!).

Первое что мы придумаем, желая написать межпроцедурный анализ, при этом не желая иметь ничего общего с инлайнингом -- это для каждого вызова функции добавлять два новых ребра в CFG, по вызову функции и по возврату из функции:

![data/exam-insensitive.png]()

Ничего хорошего sign-analysis из такого CFG не посчитает, поскольку он не думает о контексте, он лишь видит рёбра идущие в текущую вершину / из текущей вершины, и использует их при пересчете абстрактного состояния.

#### Метод ограниченного клонирования процедур, его ограничения и параметризация.

Нужно научить наш анализ контекстной чувствительности, для этого попробуем клонировать функции -- это почти то же самое, что и инлайнинг, но:
 * Клонировать можно ограниченно
 * Клонировать можно только в некоторых случаях

Будем клонировать функции только логически, для этого превратим нашу решетку `States` в решётку `Contexts -> lift(States)`. `lift` здесь используется, чтобы описать недостижимые для программы контексты. 

* Если в качестве `Contexts` взять `States`, то мы получим полную контекстную чувствительность. 
* Если взять в качесте `Contexts` множество всех вершин CFG `Call = {caller1, caller2, ..., callerN}`, в которых вызывается функция, то получаем эффект, схожий с инлайнингом на один уровень, при этом не платим за инлайнинг. Но мы всё ещё не можем сказать ничего хорошего в случае рекурсии.
* Можно начать моделировать стек вызовов на глубину не более чем `k`, тогда `Contexts = Call^{<= k}`.

Ещё можно, предполагая, что функции являются чистыми, в качестве контекста использовать только входные данные, поскольку только от этого и зависит результат чистой функции, но об этом рассказывается в следующем билете.

#### Методы улучшения контекстной чувствительности.

* Так как идея с контекстами отдалённо напоминает идею с чувствительностью к пути (тоже имеется какой-то управляющий контекст), то можно воспользоваться CEGAR (counterexample-guided abstraction refinement), но я не до конца понимаю как он работает (что-то около model-checking с поиском контр-примера с помощью SMT-solver??).
* Можно попробовать описать функцию как автомат или другую не Тьюринг-полную модель, тогда можно пользоваться методами верификации, а не статического анализа, пользуясь как раз этой неполнотой по Тьюрингу.
