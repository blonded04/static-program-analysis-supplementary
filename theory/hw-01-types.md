# Теоретическое ДЗ №1: Анализ типов

### Вопрос №1:

Что будет, если в нашу систему ввести тип Bool?
* Попробуйте переписать все правила подходящим образом
* Будет ли анализ
  * более полным?
  * более точным?

### Ответ на вопрос №1:

Для добавления типа Bool расширим категорию значений значениями `True` и `False`, а в типы добавим тип `Bool`.

Перепишем правила:
```
I                           => ||I|| = Int
B                           => ||B|| = Bool
E' bop E''                  => ||E'|| = ||E''|| /\ ||E' bop E''|| = Bool
E' op E''                   => ||E'|| = ||E''|| = ||E' op E''|| = Int
input                       => ||input|| = Int
X = E                       => ||X|| = ||E||
output E                    => ||E|| = Int \/ ||E|| = Bool
if( E ) { S }               => ||E|| = Bool
if( E ) { S' } else { S'' } => ||E|| = Bool
while( E ) { S }            => ||E|| = Bool
```

Анализ стал менее полным: 
Он отвергает большее число программ, в которых используются рекурсивные типы.

Анализ стал более точным:
Теперь рекурсивные типы определяются точнее.

### Вопрос №2:

Что будет, если в нашу систему ввести тип Array?

### Ответ на вопрос №2:

Если ввести в нашу систему Array как отдельный тип, то это потребует серьезного пересмотра существующих семантических правил, в т. ч. правил вывода типов, однако, если поступить лениво (сказать, что любой массив это указатель), то из-за этого существенно усложнится техническая реализация TIPа, который является динамических языков.

Поэтому, давайте введём Array как отдельный тип. Введём новые правила для вывода типов:
```
A[E]      => ||E|| = Int /\ ||A|| = T[] => ||A[E]|| = T
```

Аналогично случаю с Bool: анализ стал менее полным, но более точным.

### Вопрос №3:

* Придумайте правила вывода для новых операторов
* Попробуйте протипизировать программу:
```c#
main() {
    var x,y,z,t;
    x = {2,4,8,16,32,64};
    y = x[x[3]];
    z = {{},x};
    t = z[1];
    t[2] = y;
}
```

### Ответ на вопрос №3:

* Новые правила:
```
{}                  => (μx.x)[]
{a1, a2, ..., an}   => ||a1|| = ||a2|| = ... = ||an|| \/  ||{a1, a2, ..., an}|| = ||a1||[]
```
* Типизация:
```c#
var x,y,z,t;
x = {2,4,8,16,32,64}; // x = int[]
y = x[x[3]];          // y = int[int[int]] => y = int[int] => y = int
z = {{},x};           // z = {μx.x[], int[]} => z = {int[], int[]} => z = (int[])[]
t = z[1];             // t = (int[])[int] => t = int[]
t[2] = y;             // int[int] = int => OK, well typed
```

