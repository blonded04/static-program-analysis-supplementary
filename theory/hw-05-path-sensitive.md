# Теоретическое ДЗ №5: Чувствительные к пути анализы

### Вопрос №1:

Напишите вариант программы, для которой анализ открытости-закрытости файлов не показывает корректный результат даже с учётом всех возможных условий в переходах

### Ответ на вопрос №1:

В этой программе всё плохо, и даже dead-code elimination не помогает :(
```c#
main() {
    open();
    flag = 1;
    x = input();
    if (x > 10) {
        flag = 0;
        output(x);
        if (x > 20) {
            flag = 1;
            output(x);
        } else {
            close();
        }
    }
    if (flag) {
        close();
    }
}
```

Плохо всё из-за манипуляций с `flag`, усложняющих control-flow. Алгоритмически эти манипуляции верны, но каждому изменению `flag` не сопутствует вызов `open()` / `close()`.

### Вопрос №2:

Предложите, каким образом можно решить описанные в лекции проблемы в этой ситуации

### Ответ на вопрос №2:

Можно модифицировать рантайм нашего языка, чтобы `open()` был RAII: вызвали `close()` - значит выставили флажок, а когда придет время удалять дескриптор файла, созданный с помощью `open()`, то нужно вызвать `close()`, если флажок не выставлен.

Но, чтобы наш анализ __на решётках__ заработал на этом примере, можно поступить следующим образом, ослабив наш анализ. На лекции правила вычисления абстрактного состояния выглядели так:
1. `[[assume(flag == 1)]] = JOIN(n) [(flag == 0) -> {}]`
2. `[[assume(flag == 0)]] = JOIN(n) [(flag == 1) -> {}]`
3. `[[flag = 1]] = JOIN(n) [(flag == 0) -> {}]`
4. `[[flag = 0]] = JOIN(n) [(flag == 1) -> {}]`
5. `JOIN(n) = U {[[w]] | w \in pred(n)}`

Для этого, пусть `assume` проверяет не точное равенство, а факт того, что `flag` __был каким-то из значений ранее__. 
* То есть теперь наш контекст выглядит не как `{flag == 0, flag != 0}`, а как `{flag was 0, flag was 1, flag was 1 and 0}`. 
* Перед `open` и `close` мы как вставляли, так и будем вставлять `assume flag was 0` и `assume flag was 1` соответственно.

Таким образом, новые правила выглядят так:
1. `[[assume(flag was 1)]] = JOIN(n) [(flag was 0) -> {}]`
2. `[[assume(flag was 0)]] = JOIN(n) [(flag was 1) -> {}]`
3. `[[flag = 1]] = JOIN(n) [(flag was 0 and 1) -> X where (flag was 0) -> X initially]`
4. `[[flag = 1]] = JOIN(n) [(flag was 0 and 1) -> X where (flag was 1) -> X initially]`
5. `JOIN(n) = U {[[w]] | w \in pred(n)}`
